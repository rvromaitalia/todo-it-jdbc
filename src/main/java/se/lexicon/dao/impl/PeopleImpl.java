package se.lexicon.dao.impl;

import se.lexicon.dao.People;
import se.lexicon.db.ConnectionFactory;
import se.lexicon.model.Person;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * JDBC-based implementation of the {@link People} interface.
 * <p>
 * This class is responsible for performing CRUD operations on the
 * {@code person} table using JDBC. All database access logic is encapsulated
 * within this class.
 * </p>
 */
public class PeopleImpl implements People {

    /**
     * Persists a new {@link Person} entity to the database.
     * <p>
     * The {@code person_id} is generated by the database and assigned
     * back to the given {@code Person} object after insertion.
     * </p>
     *
     * @param person the {@code Person} to be persisted
     * @return the persisted {@code Person} with its generated ID set
     * @throws RuntimeException if the insert operation fails
     */
    @Override
    public Person create(Person person) {
        String sql = "INSERT INTO person (first_name, last_name) VALUES (?, ?)";
        try (Connection con = ConnectionFactory.getConnection();
             PreparedStatement ps = con.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

            ps.setString(1, person.getFirstName());
            ps.setString(2, person.getLastName());
            ps.executeUpdate();

            try (ResultSet keys = ps.getGeneratedKeys()) {
                if (keys.next()) person.setPersonId(keys.getInt(1));
            }
            return person;

        } catch (SQLException e) {
            throw new RuntimeException("Failed to create person", e);
        }
    }

    /**
     * Retrieves all {@link Person} records from the database.
     *
     * @return a list of all persons stored in the database
     * @throws RuntimeException if the query fails
     */
    @Override
    public List<Person> findAll() {
        String sql = "SELECT person_id, first_name, last_name FROM person";
        List<Person> result = new ArrayList<>();

        try (Connection con = ConnectionFactory.getConnection();
             PreparedStatement ps = con.prepareStatement(sql);
             ResultSet rs = ps.executeQuery()) {

            while (rs.next()) result.add(mapPerson(rs));
            return result;

        } catch (SQLException e) {
            throw new RuntimeException("Failed to find all persons", e);
        }
    }

    /**
     * Searches for persons whose first name or last name partially matches
     * the provided search string.
     *
     * @param name the search string used for matching names
     * @return a list of matching {@link Person} objects
     * @throws RuntimeException if the query fails
     */
    @Override
    public List<Person> findByName(String name) {
        String sql = "SELECT person_id, first_name, last_name FROM person  WHERE first_name like ?";
        List<Person> res = new ArrayList<>();
        String pattern = "%" + name + "%";

        try (Connection con = ConnectionFactory.getConnection();
             PreparedStatement statement = con.prepareStatement(sql)) {

            statement.setString(1, pattern);

            try (ResultSet rs = statement.executeQuery()) {
                while (rs.next()) {
                    res.add(mapPerson(rs));
                }
            }
            return res;

        } catch (SQLException e) {
            throw new RuntimeException("Failed to find person with a given name", e);
        }
    }

    /**
     * Finds a {@link Person} by its unique identifier.
     *
     * @param id the primary key of the person
     * @return an {@link Optional} containing the found {@code Person},
     * or {@link Optional#empty()} if no match exists
     * @throws RuntimeException if the query fails
     */
    @Override
    public Optional<Person> findbById(int id) {
        String sql = "SELECT person_id, first_name, last_name FROM person WHERE person_id = ?";
        try (Connection con = ConnectionFactory.getConnection();
             PreparedStatement ps = con.prepareStatement(sql)) {

            ps.setInt(1, id);
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    return Optional.of(mapPerson(rs));
                }
                return Optional.empty();
            }

        } catch (SQLException e) {
            throw new RuntimeException("Failed to find person by id", e);
        }
    }

    /**
     * Updates an existing {@link Person} record in the database.
     *
     * @param person the {@code Person} containing updated values
     * @return the updated {@code Person}
     * @throws RuntimeException if no record is found or the update fails
     */
    @Override
    public Person update(Person person) {
        String sql = "UPDATE person SET first_name = ?, last_name = ? WHERE person_id = ? ";
        try (Connection connection = ConnectionFactory.getConnection();
            PreparedStatement statement = connection.prepareStatement(sql)){
            statement.setString(1, person.getFirstName());
            statement.setString(2, person.getLastName());
            statement.setInt(3, person.getPersonId());

            // Execute the update statement and get the number of affected rows
            // If no rows were updated, the target record does not exist
            int updated = statement.executeUpdate();
            if (updated == 0)
                throw new RuntimeException("No person found to update with id " + person.getPersonId());
            return person;
        } catch (SQLException e){
            throw new RuntimeException("Failed to update the person", e);
        }
    }

    /**
     * Deletes a {@link se.lexicon.model.Person} from the database by its ID.
     *
     * @param id the unique identifier of the person to delete
     * @return {@code true} if a record was deleted, {@code false} otherwise
     * @throws RuntimeException if a database access error occurs
     */
    @Override
    public boolean deleteById(int id) {
        String sql = "DELETE from person WHERE person_id = ? ";
        try (Connection con = ConnectionFactory.getConnection();
            PreparedStatement preparedStatement = con.prepareStatement(sql)){
            preparedStatement.setInt(1,id);
            return preparedStatement.executeUpdate()>0;
        } catch (SQLException e){
            throw new RuntimeException("Failed to deletet person");
        }
    }

    /**
     * Maps the current row of the given {@link ResultSet} to a {@link Person} object.
     * <p>
     * This method extracts column values from the result set and constructs
     * a {@code Person} representing a single row from the {@code person} table.
     * </p>
     *
     * @param rs the {@code ResultSet} positioned at a valid row
     * @return a {@code Person} populated with values from the result set
     * @throws SQLException if a database access error occurs
     */
    private Person mapPerson(ResultSet rs) throws SQLException {
        return new Person(
                rs.getInt("person_id"),
                rs.getString("first_name"),
                rs.getString("last_name")
        );
    }
}
